var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AllureLocalHistory_openFileToReadIfExists, _AllureLocalHistory_ensureFileOpenedToAppend, _AllureLocalHistory_findFirstEntryAddress, _AllureLocalHistory_throwUnexpectedReadError;
import { once } from "node:events";
import { mkdir, open } from "node:fs/promises";
import path from "node:path";
import readline from "node:readline/promises";
import { pipeline } from "node:stream/promises";
import { isFileNotFoundError } from "./utils/misc.js";
const createHistoryItems = (testResults) => {
    return testResults
        .filter((tr) => tr.historyId)
        .map(({ id, name, fullName, environment, historyId, status, error: { message, trace } = {}, start, stop, duration, labels, }) => {
        return {
            id,
            name,
            fullName,
            environment,
            status,
            message,
            trace,
            start,
            stop,
            duration,
            labels,
            url: "",
            historyId: historyId,
            reportLinks: [],
        };
    })
        .reduce((acc, item) => {
        acc[item.historyId] = item;
        return acc;
    }, {});
};
export const createHistory = (reportUuid, reportName = "Allure Report", testCases, testResults, remoteUrl = "") => {
    const knownTestCaseIds = testCases.map((tc) => tc.id);
    return {
        uuid: reportUuid,
        name: reportName,
        timestamp: new Date().getTime(),
        knownTestCaseIds,
        testResults: createHistoryItems(testResults),
        metrics: {},
        url: remoteUrl,
    };
};
export class AllureLocalHistory {
    constructor(params) {
        this.params = params;
        _AllureLocalHistory_openFileToReadIfExists.set(this, async (filePath) => {
            try {
                return await open(filePath, "r");
            }
            catch (e) {
                if (isFileNotFoundError(e)) {
                    return undefined;
                }
                throw e;
            }
        });
        _AllureLocalHistory_ensureFileOpenedToAppend.set(this, async (filePath) => {
            try {
                return {
                    file: await open(filePath, "r+"),
                    exists: true,
                };
            }
            catch (e) {
                if (isFileNotFoundError(e)) {
                    return {
                        file: await open(filePath, "w"),
                        exists: false,
                    };
                }
                throw e;
            }
        });
        _AllureLocalHistory_findFirstEntryAddress.set(this, async (jsonlFile, limit) => {
            if (limit === undefined) {
                return 0;
            }
            if (limit < 0) {
                throw new Error(`Invalid history limit ${limit}. A history limit must be a positive integer number`);
            }
            const stat = await jsonlFile.stat();
            let { size: position } = stat;
            const { mtimeMs: originalMtime } = stat;
            if (position === 0 || limit === 0) {
                return position;
            }
            const buffer = Buffer.alloc(Buffer.poolSize);
            while (position) {
                const bytesToRead = Math.min(position, buffer.byteLength);
                position -= bytesToRead;
                const { bytesRead } = await jsonlFile.read({ buffer, length: bytesToRead, position });
                if (bytesRead !== bytesToRead) {
                    __classPrivateFieldGet(this, _AllureLocalHistory_throwUnexpectedReadError, "f").call(this, jsonlFile, originalMtime, bytesToRead, bytesRead);
                }
                for (let i = bytesToRead - 1; i >= 0; i--) {
                    if (buffer[i] === 0x0a) {
                        if (limit-- === 0) {
                            return position + i + 1;
                        }
                    }
                }
            }
            return 0;
        });
        _AllureLocalHistory_throwUnexpectedReadError.set(this, async (file, mtime, expectedBytes, actualBytes) => {
            const { mtimeMs: currentMtime } = await file.stat();
            if (currentMtime !== mtime) {
                throw new Error("The history file was modified outside Allure. " +
                    "Please, make sure the file doesn't change while Allure is running");
            }
            throw new Error(`Can't read the history file: the expected number of bytes to read ${expectedBytes} ` +
                `doesn't match the actual number ${actualBytes}`);
        });
    }
    async readHistory() {
        const fullPath = path.resolve(this.params.historyPath);
        const historyFile = await __classPrivateFieldGet(this, _AllureLocalHistory_openFileToReadIfExists, "f").call(this, fullPath);
        if (historyFile === undefined) {
            return [];
        }
        try {
            const start = await __classPrivateFieldGet(this, _AllureLocalHistory_findFirstEntryAddress, "f").call(this, historyFile, this.params.limit);
            const stream = historyFile.createReadStream({ start, encoding: "utf-8", autoClose: false });
            const historyPoints = [];
            const readlineInterface = readline
                .createInterface({ input: stream, terminal: false, crlfDelay: Infinity })
                .on("line", (line) => {
                if (line && line.trim().length) {
                    const historyEntry = JSON.parse(line);
                    historyPoints.push(historyEntry);
                }
            });
            await once(readlineInterface, "close");
            return historyPoints;
        }
        finally {
            await historyFile.close();
        }
    }
    async appendHistory(data) {
        const fullPath = path.resolve(this.params.historyPath);
        const parentDir = path.dirname(fullPath);
        const { limit } = this.params;
        await mkdir(parentDir, { recursive: true });
        const { file: historyFile, exists: historyExists } = await __classPrivateFieldGet(this, _AllureLocalHistory_ensureFileOpenedToAppend, "f").call(this, fullPath);
        try {
            const dst = historyFile.createWriteStream({ encoding: "utf-8", start: 0, autoClose: false });
            if (limit !== 0) {
                if (historyExists) {
                    const start = limit ? await __classPrivateFieldGet(this, _AllureLocalHistory_findFirstEntryAddress, "f").call(this, historyFile, limit - 1) : 0;
                    const src = historyFile.createReadStream({ start, autoClose: false });
                    await pipeline(src, dst, { end: false });
                }
                const sources = [JSON.stringify(data), Buffer.from([0x0a])];
                await pipeline(sources, dst);
            }
            if (historyExists) {
                await historyFile.truncate(dst.bytesWritten);
            }
        }
        finally {
            await historyFile.close();
        }
    }
}
_AllureLocalHistory_openFileToReadIfExists = new WeakMap(), _AllureLocalHistory_ensureFileOpenedToAppend = new WeakMap(), _AllureLocalHistory_findFirstEntryAddress = new WeakMap(), _AllureLocalHistory_throwUnexpectedReadError = new WeakMap();
