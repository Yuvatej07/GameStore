import * as preact from 'preact';
import { SVGAttributes, ComponentChild, JSX, FunctionalComponent, HTMLAttributes, VNode, ComponentChildren, FunctionComponent, ComponentProps } from 'preact';
import { Placement } from '@floating-ui/dom';
import * as preact_compat from 'preact/compat';
import { MutableRefObject, HTMLAttributes as HTMLAttributes$1, CSSProperties } from 'preact/compat';
import { Signal } from '@preact/signals';
import { AttachmentTestStepResult, Statistic, TestStatus, TestStatusTransition, SeverityLevel, TestResult } from '@allurereport/core-api';
import { RecursiveTree, Status } from 'global';
import { AttachmentData, LangLocale, TreeMapTooltipAccessor } from '@allurereport/web-commons';
import { Options } from 'sortablejs';
import { ChartMode, PieChartValues, TreeMapNode, ChartType, StabilityDistributionChartData, TestBaseGrowthDynamicsChartData, StatusAgePyramidChartData, StatusTransitionsChartData, DurationsChartData, TrSeveritiesChartData, DurationDynamicsChartData } from '@allurereport/charts-api';
import { Serie as Serie$1 } from '@/components/Charts/TrendChart';
import { AxisProps } from '@nivo/axes';
import { Serie as Serie$2, Datum as Datum$1, LineSvgProps, Point } from '@nivo/line';
import { ScaleSymlogSpec, ScaleSpec } from '@nivo/scales';
import { Margin } from '@nivo/core';
import { LegendProps, AnchoredContinuousColorsLegendProps } from '@nivo/legends';
import { DefaultTreeMapDatum, TreeMapSvgProps } from '@nivo/treemap';
import { HeatMapDatum, DefaultHeatMapDatum, HeatMapSvgProps } from '@nivo/heatmap';

declare const allureIcons: {
    amazon: string;
    arrowsChevronDown: string;
    azure: string;
    bitbucket: string;
    circleci: string;
    draggable: string;
    drone: string;
    environment: string;
    github: string;
    gitlab: string;
    jenkins: string;
    lineAlertsAlertCircle: string;
    lineAlertsFixed: string;
    lineAlertsMalfunctioned: string;
    lineAlertsNew: string;
    lineAlertsNotificationBox: string;
    lineAlertsRegressed: string;
    lineArrowsChevronDown: string;
    lineArrowsChevronDownDouble: string;
    lineArrowsChevronRight: string;
    lineArrowsChevronUp: string;
    lineArrowsChevronUpDouble: string;
    lineArrowsCornerDownRight: string;
    lineArrowsExpand3: string;
    lineArrowsRefreshCcw1: string;
    lineArrowsSortLineAsc: string;
    lineArrowsSortLineDesc: string;
    lineArrowsSwitchVertical1: string;
    lineChartsBarChartSquare: string;
    lineChartsTimeline: string;
    lineDevBug2: string;
    lineDevCodeSquare: string;
    lineDevDataflow3: string;
    lineFilesClipboardCheck: string;
    lineFilesFile2: string;
    lineFilesFileAttachment2: string;
    lineFilesFolder: string;
    lineGeneralCheck: string;
    lineGeneralCheckCircle: string;
    lineGeneralChecklist3: string;
    lineGeneralCopy3: string;
    lineGeneralDownloadCloud: string;
    lineGeneralEqual: string;
    lineGeneralEye: string;
    lineGeneralHelpCircle: string;
    lineGeneralHomeLine: string;
    lineGeneralInfoCircle: string;
    lineGeneralLink1: string;
    lineGeneralLinkExternal: string;
    lineGeneralMinusCircle: string;
    lineGeneralSearchMd: string;
    lineGeneralSettings1: string;
    lineGeneralXCircle: string;
    lineGeneralXClose: string;
    lineGeneralZap: string;
    lineHelpersFlag: string;
    lineHelpersPlayCircle: string;
    lineIconBomb2: string;
    lineImagesImage: string;
    lineLayoutsColumn2: string;
    lineLayoutsLayoutTop: string;
    lineLayoutsMaximize2: string;
    lineLayoutsMinimize2: string;
    lineSecurityKey: string;
    lineShapesDotCircle: string;
    lineShapesMoon: string;
    lineShapesSun: string;
    lineShapesThemeAuto: string;
    lineTimeClockStopwatch: string;
    playwrightLogo: string;
    reportLogo: string;
    solidAlertCircle: string;
    solidCheckCircle: string;
    solidHelpCircle: string;
    solidMinusCircle: string;
    solidPlusCircle: string;
    solidXCircle: string;
    spinner: string;
    testNew: string;
    view: string;
    viewOff: string;
};
type SvgIconProps = Omit<SVGAttributes<SVGElement>, "className" | "id" | "size" | "inline"> & {
    "size"?: "xs" | "s" | "m" | "l" | "xl";
    "className"?: string;
    "id": string;
    "inline"?: boolean;
    "data-testid"?: string;
};
declare const SvgIcon: ({ id, size, inline, className, "data-testid": dataTestId, ...restProps }: SvgIconProps) => preact.JSX.Element;

type BaseBtnProps = {
    text?: string;
    isPending?: boolean;
    size?: "xs" | "s" | "m" | "l";
    style?: "primary" | "outline" | "ghost" | "flat" | "raised";
    action?: "default" | "danger" | "positive";
    icon?: string;
    iconSize?: "xs" | "s" | "m";
    iconColor?: "primary" | "secondary";
    fullWidth?: boolean;
    isIconButton?: boolean;
    isDropdownButton?: boolean;
    onClick?: (e: MouseEvent) => void;
    type?: HTMLButtonElement["type"];
    isDisabled?: boolean;
    isActive?: boolean;
    focusable?: boolean;
    href?: string;
    rounded?: boolean;
    target?: HTMLAnchorElement["target"];
    className?: string;
    dataTestId?: string;
    leadingSlot?: ComponentChild;
    trailingSlot?: ComponentChild;
    isLink?: boolean;
};
type ButtonProps = Omit<BaseBtnProps, "text" | "isIconButton" | "isDropdownButton" | "rounded" | "isLink"> & Pick<Required<BaseBtnProps>, "text">;
declare const Button: (props: ButtonProps) => preact.JSX.Element;
type IconButtonProps = Omit<BaseBtnProps, "text" | "icon" | "autoFocus" | "fullWidth" | "isIconButton" | "isDropdownButton" | "trailingSlot" | "leadingSlot" | "isLink"> & Pick<Required<BaseBtnProps>, "icon"> & {
    rounded?: boolean;
};
declare const IconButton: (props: IconButtonProps) => preact.JSX.Element;
type DropdownButtonProps = Omit<BaseBtnProps, "type" | "autoFocus" | "isDropdownButton" | "isIconButton" | "text" | "isActive" | "isLink"> & Pick<Required<BaseBtnProps>, "text"> & {
    isExpanded?: boolean;
};
declare const DropdownButton: (props: DropdownButtonProps) => preact.JSX.Element;
declare const ButtonLink: (props: Omit<BaseBtnProps, "href" | "isLink"> & Pick<Required<BaseBtnProps>, "href">) => preact.JSX.Element;

type SpinnerProps = {
    size?: "s" | "m";
};
declare const Spinner: ({ size }: SpinnerProps) => preact.JSX.Element;

type TextProps<Tag extends keyof JSX.IntrinsicElements = "span"> = ({
    type?: "paragraph";
    size?: "s" | "m" | "l";
} | {
    type: "ui";
    size: "s" | "m" | "l" | "xs";
}) & {
    className?: string;
    bold?: boolean;
    tag?: Tag;
} & Omit<JSX.IntrinsicElements[Tag], "type" | "size" | "className" | "bold" | "tag">;
declare const Text: <Tag extends keyof JSX.IntrinsicElements = "span">({ size, tag: ElementTag, type, bold, className, children, ...rest }: TextProps<Tag>) => JSX.Element | null;
type CodeProps = {
    type?: "paragraph" | "ui";
    size?: "s" | "m";
    className?: string;
    bold?: boolean;
    tag?: keyof JSX.IntrinsicElements;
};
declare const Code: FunctionalComponent<CodeProps>;
type HeadingProps = {
    size?: "s" | "m" | "l";
    className?: string;
    tag?: keyof JSX.IntrinsicElements;
} & Omit<HTMLAttributes, "size" | "className" | "tag">;
declare const Heading: FunctionalComponent<HeadingProps>;

interface TooltipWrapperProps {
    "tooltipText"?: string;
    "tooltipTextAfterClick"?: string;
    "tooltipComponent"?: FunctionalComponent | VNode;
    "children": VNode;
    "placement"?: "top" | "bottom" | "left" | "right";
    "triggerMode"?: "hover" | "click";
    "autoHideDelay"?: number;
    "isTriggerActive"?: boolean;
    "data-testid"?: string;
    "showDelay"?: number;
}
interface TooltipProps {
    "data-testid"?: string;
}
declare const Tooltip: FunctionalComponent<TooltipProps>;
declare const useTooltip: <TriggerRef extends HTMLElement = HTMLElement, TooltipRef extends HTMLElement = HTMLElement>(props: {
    placement?: Placement;
    isVisible: boolean;
    triggerRef: MutableRefObject<TriggerRef>;
    tooltipRef: MutableRefObject<TooltipRef>;
}) => void;
declare const TooltipWrapper: FunctionalComponent<TooltipWrapperProps>;

interface StoreSignalState<T> {
    error?: string;
    loading: boolean;
    data?: T;
}
type LoadableProps<T, K = T> = {
    source: Signal<StoreSignalState<T>>;
    transformData?: (data: T) => K;
    renderData: (data: K) => JSX.Element;
    renderLoader?: () => JSX.Element;
    renderError?: (error: string) => JSX.Element;
};
declare const Loadable: <T, K = T>(props: LoadableProps<T, K>) => JSX.Element | null;

declare const PageLoader: () => preact.JSX.Element;

type Props$g = {
    placeholder?: string;
    error?: string;
    value: string;
    onChange: (value: string) => void;
    changeDebounce?: number;
    leadingSlot?: ComponentChild;
    trailingSlot?: ComponentChild;
};
declare const SearchBox: (props: Props$g) => preact.JSX.Element;

declare const Menu: {
    (props: {
        children: ComponentChildren;
        isInitialOpened?: boolean;
        size?: "s" | "m" | "l" | "xl";
        placement?: "bottom-start" | "bottom-end";
        menuTrigger: (props: {
            onClick: () => void;
            isOpened: boolean;
            setIsOpened: (isOpened: boolean) => void;
        }) => VNode;
        menuTriggerWrapper?: "div" | "span";
    }): preact.JSX.Element;
    Section: FunctionalComponent<{}>;
    Item: FunctionalComponent<ItemProps>;
    ItemWithCheckmark: FunctionalComponent<Omit<ItemProps, "rightSlot"> & {
        isChecked: boolean;
    }>;
};
type ItemProps = {
    children: ComponentChildren;
    onClick?: () => void;
    leadingIcon?: string;
    rightSlot?: ComponentChildren;
    closeMenuOnClick?: boolean;
    ariaLabel?: string;
    setIsOpened?: (isOpened: boolean) => void;
    dataTestId?: string;
};

interface ArrowButtonProps {
    isOpened?: boolean;
    iconSize?: "m" | "xs" | "s";
    buttonSize?: "m" | "xs" | "s";
    className?: string;
    icon?: string;
    onClick?: VoidFunction;
    tag?: keyof JSX.IntrinsicElements;
}
declare const ArrowButton: FunctionalComponent<ArrowButtonProps>;

type ModalGalleryProps = {
    attachments: AttachmentTestStepResult[] | undefined;
};
interface ModalDataProps<T = any> {
    data?: T;
    component: VNode;
    preview?: boolean;
    isModalOpen?: boolean;
    closeModal?: () => void;
    attachments?: AttachmentTestStepResult[];
    title?: string;
}
interface ModalTranslations {
    tooltipPreview: string;
    tooltipDownload: string;
    openInNewTabButton: string;
}
interface ModalTranslationsProps {
    translations: ModalTranslations;
}
declare const Modal: ({ data, isModalOpen, preview, component, attachments, closeModal, translations, title, }: ModalDataProps & ModalTranslationsProps) => preact.JSX.Element | null;

interface TreeProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    tree: RecursiveTree;
    name?: string;
    root?: boolean;
    statusFilter?: Status;
    collapsedTrees: Set<string>;
    toggleTree: (id: string) => void;
    navigateTo: (id: string) => void;
    routeId?: string;
}
declare const Tree: FunctionalComponent<TreeProps>;

interface TreeHeaderProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    categoryTitle: string;
    isOpened: boolean;
    toggleTree: () => void;
    statusFilter?: Status;
}
declare const TreeHeader: FunctionComponent<TreeHeaderProps>;

interface TreeSectionProps {
    title: string;
    isOpened: boolean;
    toggleTree: () => void;
    icon?: string;
}
declare const TreeSection: FunctionComponent<TreeSectionProps>;

interface TreeItemProps {
    name: string;
    status: TestStatus;
    duration?: number;
    retriesCount?: number;
    flaky?: boolean;
    transition?: TestStatusTransition;
    transitionTooltip?: string;
    id: string;
    groupOrder: number;
    marked?: boolean;
    navigateTo: (id: string) => void;
    tooltips: Record<string, string>;
}
declare const TreeItem: FunctionComponent<TreeItemProps>;

interface TestStatusIconProps {
    status?: TestStatus;
    className?: string;
    classNameIcon?: string;
}
declare const TreeItemIcon: FunctionalComponent<TestStatusIconProps>;

interface TreeStatusBarProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    maxWidth?: number;
    minWidth?: number;
    offset?: number;
    statusFilter?: Status;
}
declare const TreeStatusBar: FunctionalComponent<TreeStatusBarProps>;

type I18nKeys$a = "mode.diff" | "mode.actual" | "mode.expected" | "mode.side-by-side" | "mode.overlay" | "empty.failed-to-load" | "image.diff" | "image.actual" | "image.expected";
type I18nProp$b = (key: I18nKeys$a, props?: Record<string, unknown>) => string | undefined;

type ImageDiff$1 = {
    name?: string;
    expected?: string;
    actual?: string;
    diff?: string;
};

type Props$f = {
    diff: ImageDiff$1;
    i18n?: I18nProp$b;
};
declare const ImageDiff: (props: Props$f) => preact.JSX.Element;

type AttachmentProps = {
    attachment: AttachmentData | null;
    item: AttachmentTestStepResult;
    i18n?: (key: any) => string;
};
type I18nProp$a = {
    imageDiff: ComponentProps<typeof ImageDiff>["i18n"];
};

interface AttachmentTestStepResultProps {
    item: AttachmentTestStepResult;
    previewable?: boolean;
    i18n?: I18nProp$a;
}
declare const Attachment: (props: AttachmentTestStepResultProps) => preact.JSX.Element | null;

declare const AttachmentCode: (props: AttachmentProps) => preact.JSX.Element | null;

type HtmlAttachmentPreviewProps = {
    attachment: {
        text: string;
    };
};
declare const HtmlPreview: FunctionalComponent<HtmlAttachmentPreviewProps>;

declare const AttachmentImage: (props: AttachmentProps) => preact.JSX.Element;

declare const AttachmentVideo: ({ attachment, item }: AttachmentProps) => preact.JSX.Element;

declare const AttachmentEmpty: ({ children }: {
    children: ComponentChildren;
}) => preact.JSX.Element;

declare const CodeViewer: FunctionalComponent<{
    code?: string;
    children?: ComponentChildren;
    className?: string;
}>;

type Props$e = {
    size?: "s" | "m" | "l";
    count: number;
    truncateCount?: boolean;
    status?: TestStatus;
};
declare const Counter: (props: Props$e) => preact.JSX.Element;

type Props$d = {
    value: boolean;
    label: string;
    size?: "s" | "m";
    onChange: (value: boolean) => void;
    focusable?: boolean;
};
declare const Toggle: (props: Props$d) => preact.JSX.Element;

type Props$c = {
    href?: string;
    children: ComponentChildren;
    onClick?: (e: MouseEvent) => void;
};
declare const Link: (props: Props$c) => preact.JSX.Element;

declare const Label: FunctionComponent;

type StatusLabelProps = {
    status: TestStatus;
    className?: string;
};
declare const StatusLabel: FunctionalComponent<StatusLabelProps>;

declare const ReportLogoFull: (props: {
    className?: string;
}) => preact.JSX.Element;

declare const ReportLogo: (props: {
    className?: string;
    logo?: string;
}) => preact.JSX.Element;

interface WidgetProps {
    title?: string;
    centerContent?: boolean;
    dropShadow?: boolean;
}
declare const Widget: FunctionalComponent<WidgetProps>;

type TagSkin = "successful" | "failed" | "warning" | "neutral" | "successful-light" | "failed-light" | "warning-light" | "neutral-light" | "secondary";
interface TagProps {
    "className"?: string;
    "skin"?: TagSkin;
    "data-testid"?: string;
    "children": ComponentChildren;
}
declare const Tag: ({ className, skin, children, "data-testid": dataTestId }: TagProps) => preact.JSX.Element;

type GridKind = "default" | "swap";
interface GridProps extends HTMLAttributes$1<HTMLDivElement> {
    options?: Options;
    kind?: GridKind;
    className?: string;
}
declare const Grid: FunctionComponent<GridProps>;

interface GridItemProps extends HTMLAttributes$1<HTMLDivElement> {
    className?: string;
    dndEnabled?: boolean;
}
declare const GridItem: FunctionComponent<GridItemProps>;

interface LanguagePickerProps {
    locale: LangLocale;
    setLocale: (locale: LangLocale) => void;
    availableLocales?: LangLocale[];
}
declare const LanguagePicker: ({ locale, setLocale, availableLocales }: LanguagePickerProps) => preact.JSX.Element;

type Theme = "light" | "dark" | "auto";
interface ThemeButtonProps {
    theme: Theme;
    toggleTheme: () => void;
}
declare const ThemeButton: ({ theme, toggleTheme }: ThemeButtonProps) => preact.JSX.Element;

type Props$b = {
    icon: string;
    tooltip?: string;
    className?: string;
    style?: "primary" | "secondary";
};
declare const IconLabel: FunctionalComponent<Props$b>;

interface TrendChartWidgetPropsTranslations {
    "no-results": string;
}
interface TrendChartWidgetProps<TSlice = {
    metadata: {
        executionId: string;
    };
}> {
    title: string;
    mode: ChartMode;
    items: readonly Serie$1[];
    slices: readonly TSlice[];
    min: number;
    max: number;
    height?: CSSProperties["height"];
    width?: CSSProperties["width"];
    rootAriaLabel?: string;
    translations: TrendChartWidgetPropsTranslations;
    dropShadow?: boolean;
}
declare const TrendChartWidget: ({ title, mode, items, slices, min, max, height, width, rootAriaLabel, translations, }: TrendChartWidgetProps) => preact_compat.JSX.Element;

type SuccessRatePieChartProps = PieChartValues & {
    className?: string;
};
declare const SuccessRatePieChart: ({ slices, percentage, className }: SuccessRatePieChartProps) => preact.JSX.Element;

type Datum = Omit<Datum$1, "x" | "y"> & {
    x: string | number | Date;
    y: number;
};
type Serie = Omit<Serie$2, "id" | "data"> & {
    id: string | number;
    data: readonly Datum[];
};
type BaseLineSvgProps = Omit<LineSvgProps, "useMesh" | "enableSlices">;
declare enum TrendChartKind {
    Mesh = "Mesh",
    SlicesX = "SlicesX",
    SlicesY = "SlicesY"
}
type TrendChartKindConfig = Pick<LineSvgProps, "useMesh" | "enableSlices">;
type SymlogScaleOptions = Pick<ScaleSymlogSpec, "constant" | "reverse">;
interface Slice {
    id: string;
    height: number;
    width: number;
    x: number;
    y: number;
    x0: number;
    y0: number;
    points: Point[];
}
type TrendChartSliceClickHandler = (slice: Slice, event: MouseEvent) => void;
type TrendChartSliceTouchHandler = (slice: Slice, event: TouchEvent) => void;
interface BaseTrendChartProps extends Omit<BaseLineSvgProps, "onClick" | "onTouchEnd" | "axisBottom"> {
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    axisBottom?: Omit<AxisProps, "tickValues">;
}
interface MeshTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.Mesh;
    onClick?: (point: Point, event: MouseEvent) => void;
    onTouchEnd?: (point: Point, event: TouchEvent) => void;
}
interface SlicesTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.SlicesX | TrendChartKind.SlicesY;
    onSliceClick?: TrendChartSliceClickHandler;
    onSliceTouchEnd?: TrendChartSliceTouchHandler;
}
type TrendChartProps = MeshTrendChartProps | SlicesTrendChartProps;

declare const TrendChart: FunctionalComponent<TrendChartProps>;

declare const defaultTrendChartLegendConfig: LegendProps;
declare const defaultTrendChartAxisBottomConfig: AxisProps;
declare const defaultTrendChartAxisLeftConfig: AxisProps;
declare const defaultTrendChartMarginConfig: Margin;
declare const defaultTrendChartXScaleConfig: ScaleSpec;
declare const defaultTrendChartYScaleConfig: ScaleSpec;
declare const defaultTrendChartConfig: Partial<LineSvgProps>;

declare const makeSymlogScale: (min: number, max: number, options?: SymlogScaleOptions) => ScaleSymlogSpec;
declare const makeSymlogScaleBySeries: (series: Serie[], options?: SymlogScaleOptions) => ScaleSymlogSpec;

type ResponsiveTreeChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> = Omit<TreeMapSvgProps<Datum>, "width" | "height">;
interface ParentLabelControlOptions {
    parentSkipSize?: number;
}
type BaseTreeMapChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> = Omit<ResponsiveTreeChartProps<Datum>, "colors" | "tooltip"> & ParentLabelControlOptions;
interface TreeMapChartProps<Datum extends DefaultTreeMapDatum = TreeMapNode> extends BaseTreeMapChartProps<Datum> {
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    showLegend?: boolean;
    legendMinValue?: number;
    legendMaxValue?: number;
    colors: (value: number, domain?: number[]) => string;
    formatLegend?: (value: number) => string;
    legendDomain?: number[];
    tooltipRows?: TreeMapTooltipAccessor;
}
type TreeMapChartNode = DefaultTreeMapDatum;

declare const TreeMapChart: FunctionalComponent<TreeMapChartProps & {
    labelColor?: (node: any) => string;
}>;

declare const defaultTreeChartConfig: Partial<ResponsiveTreeChartProps<DefaultTreeMapDatum>>;

interface TreeMapChartWidgetProps extends Omit<TreeMapChartProps, "colors"> {
    title: string;
    colors: (value: number, domain?: number[]) => string;
    formatLegend?: (value: number) => string;
    translations: Record<string, string>;
    showLegend?: boolean;
    domain?: number[];
    legendDomain?: number[];
}

declare const TreeMapChartWidget: FunctionalComponent<TreeMapChartWidgetProps & {
    chartType: ChartType.CoverageDiff | ChartType.SuccessRateDistribution;
}>;

declare const useCoverageDiffColors: (theme?: string) => (value: number) => string;
declare const useSuccessRateDistributionColors: (theme?: string) => (value: number) => string;
declare const useCoverageDiffTextColors: (theme?: string) => (value: number) => string;

type ResponsiveHeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> = Omit<HeatMapSvgProps<Datum, ExtraProps>, "width" | "height">;
type BaseHeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> = Omit<ResponsiveHeatMapProps<Datum, ExtraProps>, "width" | "height" | "colors">;
interface HeatMapProps<Datum extends HeatMapDatum = DefaultHeatMapDatum, ExtraProps extends object = Record<string, unknown>> extends BaseHeatMapProps<Datum, ExtraProps> {
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
}
type HeatMapLegendConfig = Omit<AnchoredContinuousColorsLegendProps, "scale" | "containerWidth" | "containerHeight">;

declare const HeatMap: FunctionalComponent<HeatMapProps>;

declare const defaultHeatMapMarginConfig: {
    top: number;
    right: number;
    bottom: number;
    left: number;
};
declare const DEFAULT_HEAT_MAP_EMPTY_COLOR = "#E0E0E0";
declare const DEFAULT_HEAT_MAP_HEIGHT = 400;
declare const DEFAULT_HEAT_MAP_WIDTH = "100%";
declare const DEFAULT_HEAT_MAP_EMPTY_LABEL = "No data available";
declare const DEFAULT_HEAT_MAP_EMPTY_ARIA_LABEL = "No data available";
declare const DEFAULT_HEAT_MAP_X_INNER_PADDING = 0.05;
declare const DEFAULT_HEAT_MAP_Y_INNER_PADDING = 0.05;
declare const DEFAULT_HEAT_MAP_FORCE_SQUARE = true;
declare const DEFAULT_HEAT_MAP_VALUE_FORMAT = ">-.2%";
declare const defaultHeatMapAxisLeftConfig: AxisProps;
declare const defaultHeatMapAxisTopConfig: AxisProps;
declare const defaultHeatMapLegendConfig: HeatMapLegendConfig;

interface HeatMapWidgetProps extends HeatMapProps {
    title: string;
    translations: Record<string, string>;
}

declare const HeatMapWidget: FunctionalComponent<HeatMapWidgetProps>;

type I18nKeys$9 = "no-results" | "legend.stabilityRate";
type I18nProp$9 = (key: I18nKeys$9, props?: Record<string, unknown>) => string;
type Props$a = Omit<StabilityDistributionChartData, "type"> & {
    i18n: I18nProp$9;
};

declare const StabilityDistributionWidget: FunctionalComponent<Props$a>;

type I18nKeys$8 = `status.new${TestStatus}` | `status.removed${TestStatus}` | "legend.trend" | "no-history" | "no-results" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history";
type I18nProp$8 = (key: I18nKeys$8, props?: Record<string, unknown>) => string;
type Props$9 = Omit<TestBaseGrowthDynamicsChartData, "type"> & {
    i18n: I18nProp$8;
};

declare const TestBaseGrowthDynamicsChartWidget: FunctionalComponent<Props$9>;

type FBSUStatus = Exclude<TestStatus, "passed">;
type I18nKeys$7 = `status.${FBSUStatus}` | "no-history" | "no-results" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history";
type I18nProp$7 = (key: I18nKeys$7, props?: Record<string, unknown>) => string;
type Props$8 = Omit<StatusAgePyramidChartData, "type" | "statuses"> & {
    i18n: I18nProp$7;
    statuses: FBSUStatus[];
};

declare const StatusAgePyramidChartWidget: FunctionalComponent<Props$8>;

type Props$7 = {
    data: {
        layer: string;
        testCount: number;
        successRate: number;
        percentage: number;
    }[];
    title: string;
    translations: Record<string, string>;
    width?: JSX.CSSProperties["width"];
    height?: JSX.CSSProperties["height"];
};
declare const TestingPyramidWidget: (props: Props$7) => JSX.Element;

type I18nKeys$6 = "status.passed" | "status.failed" | "status.skipped" | "status.unknown" | "status.broken" | "percentage" | "of" | "tests.new" | "tests.flaky" | "tests.retries" | "total";
type I18nProp$6 = (key: I18nKeys$6, props?: Record<string, unknown>) => string;
type Props$6 = {
    title?: string;
    i18n?: I18nProp$6;
    data: Statistic;
    statuses?: TestStatus[];
    metric?: TestStatus;
};

declare const CurrentStatusChartWidget: FunctionalComponent<Props$6>;

type I18nKeys$5 = "status.passed" | "status.failed" | "status.skipped" | "status.unknown" | "status.broken" | "no-history" | "no-results" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history";
type I18nProp$5 = (key: I18nKeys$5, props?: Record<string, unknown>) => string;
type Props$5 = {
    title?: string;
    data: {
        statistic: Statistic;
        id: string;
        timestamp: number;
        name: string;
    }[];
    limit?: number;
    statuses?: TestStatus[];
    i18n: I18nProp$5;
};

declare const StatusDynamicsChartWidget: FunctionalComponent<Props$5>;

type I18nKeys$4 = "transitions.new" | "transitions.fixed" | "transitions.regressed" | "transitions.malfunctioned" | "legend.trend" | "no-history" | "no-results" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history";
type I18nProp$4 = (key: I18nKeys$4, props?: Record<string, unknown>) => string;
type Props$4 = Omit<StatusTransitionsChartData, "type"> & {
    statuses?: TestStatus[];
    i18n: I18nProp$4;
};

declare const StatusTransitionsChartWidget: FunctionalComponent<Props$4>;

type I18nKeys$3 = "no-history" | "no-results" | "ticks.durationRange" | "tooltips.durationRange" | "legend.value" | "legend.total";
type I18nProp$3 = (key: I18nKeys$3, props?: Record<string, unknown>) => string;
type Props$3 = Omit<DurationsChartData, "type"> & {
    i18n: I18nProp$3;
};

declare const DurationsChartWidget: FunctionalComponent<Props$3>;

type I18nKeys$2 = `status.${TestStatus}` | `severity.${SeverityLevel | "unset"}` | "no-results" | "ticks.current";
type I18nProp$2 = (key: I18nKeys$2, props?: Record<string, unknown>) => string;
type Props$2 = Omit<TrSeveritiesChartData, "type"> & {
    i18n: I18nProp$2;
};

declare const TrSeveritiesChartWidget: FunctionalComponent<Props$2>;

type I18nKeys$1 = "no-results" | "durations.sequential" | "durations.duration" | "durations.speedup" | "ticks.current" | "ticks.history" | "tooltips.current" | "tooltips.history" | "legend.duration" | "legend.speedup";
type I18nProp$1 = (key: I18nKeys$1, props?: Record<string, unknown>) => string;
type Props$1 = Omit<DurationDynamicsChartData, "type"> & {
    i18n: I18nProp$1;
};

declare const DurationDynamicsChartWidget: FunctionalComponent<Props$1>;

type TimlineTr = Pick<TestResult, "id" | "name" | "status" | "flaky" | "hidden" | "environment" | "start" | "duration" | "historyId"> & {
    host: string;
    thread: string;
};
type TimelineSegment = {
    timeRange: [Date, Date];
    val: number;
    status: "failed" | "broken" | "passed" | "skipped" | "unknown";
    hidden?: boolean;
    label: string;
    labelGroup: string[];
    id: string;
};
type TimelineDataGroup = {
    id: string;
    name: string;
    segments: TimelineSegment[];
};
type TimelineData = TimelineDataGroup[];
type TimelineChartData = TimlineTr[];

type TimelineProps = {
    data?: TimelineData;
    width?: number;
    enableAnimations?: boolean;
    translations: {
        empty: string;
        selected: (props: {
            count: number;
            percentage: string;
            minDuration: string;
            maxDuration: string;
        }) => string;
    };
};
declare const Timeline: FunctionComponent<Omit<TimelineProps, "data"> & {
    data: TimelineChartData;
    dataId: string;
}>;

type SummaryTestResult = Pick<TestResult, "name" | "id" | "status" | "duration">;
type ReportSummary = {
    href?: string;
    remoteHref?: string;
    jobHref?: string;
    pullRequestHref?: string;
    name: string;
    stats: Statistic;
    status: TestStatus;
    duration: number;
    plugin?: string;
    newTests?: SummaryTestResult[];
    flakyTests?: SummaryTestResult[];
    retryTests?: SummaryTestResult[];
    createdAt?: number;
};
type StatusI18nKeys = "status.failed" | "status.broken" | "status.passed" | "status.skipped" | "status.unknown";
type MetadataI18nKeys = "metadata.new" | "metadata.retry" | "metadata.flaky";
type I18nKeys = MetadataI18nKeys | StatusI18nKeys | "in" | "new" | "retry" | "flaky" | "total" | "createdAt";
type I18nProp = (key: I18nKeys, props?: Record<string, any>) => string | undefined;

type ReportSummaryCardProps = {
    i18n: I18nProp;
    summary: ReportSummary;
};
declare const ReportSummaryCard: (props: ReportSummaryCardProps) => preact.JSX.Element;

declare const useTheme: () => string;
declare const ThemeProvider: (props: {
    children: ComponentChildren;
    theme: string;
}) => preact.JSX.Element;

type Size = "s" | "m" | "xs";
type Props = {
    title?: ComponentChildren;
    description?: ComponentChildren;
    icon?: string;
    iconColor?: "skat" | "aldebaran" | "castor" | "atlas" | "betelgeuse" | "sirius" | "antares" | "gliese" | "capella" | "rigel" | "mirach" | "rau";
    fullHeight?: boolean;
    size?: Size;
    className?: string;
    iconClassName?: string;
    border?: boolean;
};
declare const EmptyView: FunctionalComponent<Props>;

export { ArrowButton, Attachment, AttachmentCode, AttachmentEmpty, AttachmentImage, AttachmentVideo, Button, ButtonLink, Code, CodeViewer, Counter, CurrentStatusChartWidget, DEFAULT_HEAT_MAP_EMPTY_ARIA_LABEL, DEFAULT_HEAT_MAP_EMPTY_COLOR, DEFAULT_HEAT_MAP_EMPTY_LABEL, DEFAULT_HEAT_MAP_FORCE_SQUARE, DEFAULT_HEAT_MAP_HEIGHT, DEFAULT_HEAT_MAP_VALUE_FORMAT, DEFAULT_HEAT_MAP_WIDTH, DEFAULT_HEAT_MAP_X_INNER_PADDING, DEFAULT_HEAT_MAP_Y_INNER_PADDING, DropdownButton, DurationDynamicsChartWidget, DurationsChartWidget, EmptyView, Grid, GridItem, Heading, HeatMap, HeatMapWidget, HtmlPreview, IconButton, IconLabel, ImageDiff, Label, LanguagePicker, Link, Loadable, Menu, Modal, PageLoader, ReportLogo, ReportLogoFull, ReportSummaryCard, SearchBox, Spinner, StabilityDistributionWidget, StatusAgePyramidChartWidget, StatusDynamicsChartWidget, StatusLabel, StatusTransitionsChartWidget, SuccessRatePieChart, SvgIcon, Tag, TestBaseGrowthDynamicsChartWidget, TestingPyramidWidget, Text, ThemeButton, ThemeProvider, Timeline, Toggle, Tooltip, TooltipWrapper, TrSeveritiesChartWidget, Tree, TreeHeader, TreeItem, TreeItemIcon, TreeMapChart, TreeMapChartWidget, TreeSection, TreeStatusBar, TrendChart, TrendChartKind, TrendChartWidget, Widget, allureIcons, defaultHeatMapAxisLeftConfig, defaultHeatMapAxisTopConfig, defaultHeatMapLegendConfig, defaultHeatMapMarginConfig, defaultTreeChartConfig, defaultTrendChartAxisBottomConfig, defaultTrendChartAxisLeftConfig, defaultTrendChartConfig, defaultTrendChartLegendConfig, defaultTrendChartMarginConfig, defaultTrendChartXScaleConfig, defaultTrendChartYScaleConfig, makeSymlogScale, makeSymlogScaleBySeries, useCoverageDiffColors, useCoverageDiffTextColors, useSuccessRateDistributionColors, useTheme, useTooltip };
export type { Datum, GridItemProps, GridProps, HeatMapProps, HeatMapWidgetProps, LanguagePickerProps, MeshTrendChartProps, ModalDataProps, ModalGalleryProps, ModalTranslations, ModalTranslationsProps, ParentLabelControlOptions, ReportSummaryCardProps, ResponsiveTreeChartProps, Serie, Slice, SlicesTrendChartProps, SymlogScaleOptions, TagProps, TagSkin, Theme, ThemeButtonProps, TreeMapChartNode, TreeMapChartProps, TreeMapChartWidgetProps, TrendChartKindConfig, TrendChartProps, TrendChartSliceClickHandler, TrendChartSliceTouchHandler };
