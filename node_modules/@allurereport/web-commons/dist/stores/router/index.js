import { computed } from "@preact/signals-core";
import { paramsToSearchParams } from "../url/helpers.js";
import { currentUrl, goTo } from "../url/index.js";
export const router = computed(() => {
    const hash = currentUrl.value.hash.startsWith("#") ? currentUrl.value.hash.slice(1) : currentUrl.value.hash;
    return {
        path: hash,
        pathParts: hash.split("/").filter(Boolean),
    };
});
const createRouteUrl = (path, params) => {
    return path
        .split("/")
        .map((part) => {
        if (part.startsWith(":")) {
            const isOptional = part.endsWith("?");
            const paramKey = isOptional ? part.slice(1, -1) : part.slice(1);
            const value = params[paramKey];
            if (value) {
                return value.toString();
            }
            if (isOptional) {
                return "";
            }
            return part;
        }
        return part;
    })
        .filter(Boolean)
        .join("/");
};
export const navigateTo = (to) => {
    const { path, params = {}, replace = false, searchParams = {}, keepSearchParams = false } = to;
    const currentPathname = currentUrl.value.pathname;
    const newUrl = new URL(currentPathname, currentUrl.value.origin);
    const routeUrl = createRouteUrl(path, params);
    newUrl.hash = routeUrl === "" || routeUrl === "/" ? "" : `#${routeUrl}`;
    if (keepSearchParams) {
        paramsToSearchParams(currentUrl.value.params, newUrl.searchParams);
    }
    Object.entries(searchParams).forEach(([key, value]) => {
        if (!value) {
            return;
        }
        if (Array.isArray(value)) {
            for (const v of value) {
                newUrl.searchParams.set(key, v.toString());
            }
        }
        newUrl.searchParams.set(key, value.toString());
    });
    goTo(newUrl, { replace });
};
export const createRoute = (path, validate = () => true) => {
    if (path === "/" && router.value.pathParts.length === 0) {
        return { matches: true, params: {} };
    }
    const routeParts = path.split("/").filter(Boolean);
    const currentParts = router.value.pathParts;
    const params = {};
    let routeIndex = 0;
    let currentIndex = 0;
    while (routeIndex < routeParts.length && currentIndex < currentParts.length) {
        const routePart = routeParts[routeIndex];
        const currentPart = currentParts[currentIndex];
        if (routePart.startsWith(":")) {
            const isOptional = routePart.endsWith("?");
            const paramKey = isOptional ? routePart.slice(1, -1) : routePart.slice(1);
            params[paramKey] = currentPart;
            routeIndex++;
            currentIndex++;
        }
        else if (routePart === currentPart) {
            routeIndex++;
            currentIndex++;
        }
        else {
            return { matches: false, params: {} };
        }
    }
    while (routeIndex < routeParts.length) {
        const routePart = routeParts[routeIndex];
        if (routePart.startsWith(":") && routePart.endsWith("?")) {
            const paramKey = routePart.slice(1, -1);
            params[paramKey] = undefined;
            routeIndex++;
        }
        else {
            return { matches: false, params: {} };
        }
    }
    const matches = currentIndex === currentParts.length;
    const route = { matches, params };
    return { matches: matches && validate(route), params };
};
