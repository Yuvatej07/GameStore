import { aqlArrayConditionExpression, aqlBinaryExpression, aqlConditionExpression, aqlParenExpression, createAqlPredicate, } from "@allurereport/aql";
import { MAX_ARRAY_FIELD_VALUES, } from "./model.js";
const buildAqlFromFieldFilter = (field) => {
    const { value: fieldValue } = field;
    const { key, type, strict, value } = fieldValue;
    if (type === "array") {
        if (value.length === 0) {
            throw new Error("ArrayField value cannot be empty");
        }
        if (strict === false) {
            return buildArrayIntersectionFilter(key, value, MAX_ARRAY_FIELD_VALUES);
        }
        return aqlArrayConditionExpression({
            type: "arrayCondition",
            left: {
                identifier: key,
            },
            operator: "IN",
            right: value.map((item) => ({
                value: item,
                type: "STRING",
            })),
        });
    }
    let expressionValue;
    let valueType;
    let operator = "EQ";
    switch (type) {
        case "number": {
            expressionValue = String(value);
            operator = (strict ?? true) ? "EQ" : "CONTAINS";
            valueType = "NUMBER";
            break;
        }
        case "boolean": {
            expressionValue = value ? "true" : "false";
            valueType = "BOOLEAN";
            operator = "EQ";
            break;
        }
        case "string": {
            expressionValue = String(value);
            operator = (strict ?? true) ? "EQ" : "CONTAINS";
            valueType = "STRING";
            break;
        }
        default: {
            const exhaustiveCheck = type;
            throw new Error(`Unsupported field type: ${String(exhaustiveCheck)}`);
        }
    }
    return aqlConditionExpression({
        type: "condition",
        left: {
            identifier: key,
        },
        operator,
        right: {
            value: expressionValue,
            type: valueType,
        },
    });
};
export const buildFieldFilters = (filters) => {
    if (filters.length === 0) {
        throw new Error("chainFieldFilters: filters array cannot be empty");
    }
    const buildAqlFromFilterGroup = (group) => {
        const { value } = group;
        if (value.length === 0) {
            throw new Error("buildFieldFilters: value array cannot be empty");
        }
        if (value.length === 1) {
            return buildFieldFilters([value[0]]);
        }
        return aqlParenExpression({
            type: "paren",
            expression: buildFieldFilters(value),
        });
    };
    if (filters.length === 1) {
        const [filter] = filters;
        if (filter.type === "field") {
            return buildAqlFromFieldFilter(filter);
        }
        return buildAqlFromFilterGroup(filter);
    }
    const [first, second, ...rest] = filters;
    if (rest.length === 0) {
        return aqlBinaryExpression({
            type: "binary",
            operator: first.logicalOperator ?? "AND",
            left: buildFieldFilters([first]),
            right: buildFieldFilters([second]),
        });
    }
    return rest.reduce((acc, filter) => {
        return aqlBinaryExpression({
            type: "binary",
            operator: filter.logicalOperator ?? "AND",
            left: acc,
            right: buildFieldFilters([filter]),
        });
    }, buildFieldFilters([first, second]));
};
const buildArrayIntersectionFilter = (key, values, maxIndex = 20) => {
    if (values.length === 0) {
        throw new Error("buildArrayIntersectionFilter: values array cannot be empty");
    }
    const conditionsPerValue = values.map((value) => {
        const indexConditions = Array.from({ length: maxIndex + 1 }, (_, index) => {
            return aqlConditionExpression({
                type: "condition",
                left: {
                    identifier: key,
                    param: {
                        value: index,
                        type: "number",
                    },
                },
                operator: "EQ",
                right: {
                    value,
                    type: "STRING",
                },
            });
        });
        if (indexConditions.length === 1) {
            return indexConditions[0];
        }
        return indexConditions.reduce((acc, condition, index) => {
            if (index === 0) {
                return condition;
            }
            return aqlBinaryExpression({
                type: "binary",
                operator: "OR",
                left: acc,
                right: condition,
            });
        }, indexConditions[0]);
    });
    if (conditionsPerValue.length === 1) {
        return conditionsPerValue[0];
    }
    return conditionsPerValue.reduce((acc, condition, index) => {
        if (index === 0) {
            return condition;
        }
        return aqlBinaryExpression({
            type: "binary",
            operator: "OR",
            left: acc,
            right: condition,
        });
    }, conditionsPerValue[0]);
};
export const buildFilterPredicate = (filters) => {
    return createAqlPredicate(buildFieldFilters(filters));
};
