import { ChartType, } from "@allurereport/charts-api";
import { DEFAULT_ENVIRONMENT } from "@allurereport/core-api";
import { generateCurrentStatusChart } from "./generateCurrentStatusChart.js";
import { generateDurationDynamicsChart } from "./generateDurationDynamicsChart.js";
import { generateDurationsChart } from "./generateDurationsChart.js";
import { generateStabilityDistributionChart } from "./generateStabilityDistributionChart.js";
import { generateStatusAgePyramid } from "./generateStatusAgePyramid.js";
import { generateStatusDynamicsChart } from "./generateStatusDynamicsChart.js";
import { generateStatusTransitionsChart } from "./generateStatusTransitionsChart.js";
import { generateTestBaseGrowthDynamicsChart } from "./generateTestBaseGrowthDynamicsChart.js";
import { generateTestingPyramidChart } from "./generateTestingPyramidChart.js";
import { generateTrSeveritiesChart } from "./generateTrSeveritiesChart.js";
import { generateHeatMapChart } from "./heatMap.js";
import { generateTreeMapChart } from "./treeMap.js";
const generateChartData = async (props) => {
    const { env, chartsOptions, store, generateUuid, filter } = props;
    const result = {};
    const getTrs = async () => {
        let trs = [];
        if (env) {
            trs = await store.testResultsByEnvironment(env);
        }
        else {
            trs = await store.allTestResults();
        }
        if (filter) {
            trs = trs.filter(filter);
        }
        return trs;
    };
    const getHistoryDataPoints = async () => {
        let historyDataPoints = [];
        if (env) {
            historyDataPoints = await store.allHistoryDataPointsByEnvironment(env);
        }
        historyDataPoints = await store.allHistoryDataPoints();
        if (typeof filter === "function") {
            historyDataPoints = historyDataPoints.map((hdp) => {
                const trsEntries = Object.entries(hdp.testResults);
                const filteredTrsEntries = trsEntries.filter(([, tr]) => {
                    try {
                        return filter(tr);
                    }
                    catch (error) {
                        return false;
                    }
                });
                return {
                    ...hdp,
                    testResults: Object.fromEntries(filteredTrsEntries),
                };
            });
        }
        return historyDataPoints;
    };
    const getStatistic = () => {
        return store.testsStatistic((tr) => {
            if (env && tr.environment !== env) {
                return false;
            }
            if (typeof filter === "function" && !filter(tr)) {
                return false;
            }
            return true;
        });
    };
    const storeData = await Promise.all([
        await getHistoryDataPoints(),
        await getTrs(),
        await getStatistic(),
    ]).then(([historyDataPoints, testResults, statistic]) => ({
        historyDataPoints,
        testResults,
        statistic,
    }));
    for (const chartOption of chartsOptions) {
        const chartId = generateUuid();
        switch (chartOption.type) {
            case ChartType.CurrentStatus:
                result[chartId] = generateCurrentStatusChart(chartOption, storeData);
                break;
            case ChartType.StatusDynamics:
                result[chartId] = generateStatusDynamicsChart({ options: chartOption, storeData });
                break;
            case ChartType.StatusTransitions:
                result[chartId] = generateStatusTransitionsChart({ options: chartOption, storeData });
                break;
            case ChartType.Durations:
                result[chartId] = generateDurationsChart({ options: chartOption, storeData });
                break;
            case ChartType.DurationDynamics:
                result[chartId] = generateDurationDynamicsChart({ options: chartOption, storeData });
                break;
            case ChartType.StabilityDistribution:
                result[chartId] = generateStabilityDistributionChart({ options: chartOption, storeData });
                break;
            case ChartType.TestBaseGrowthDynamics:
                result[chartId] = generateTestBaseGrowthDynamicsChart({ options: chartOption, storeData });
                break;
            case ChartType.StatusAgePyramid:
                result[chartId] = generateStatusAgePyramid({ options: chartOption, storeData });
                break;
            case ChartType.TrSeverities:
                result[chartId] = generateTrSeveritiesChart({ options: chartOption, storeData });
                break;
            case ChartType.CoverageDiff:
                result[chartId] = generateTreeMapChart(chartOption, storeData);
                break;
            case ChartType.SuccessRateDistribution:
                result[chartId] = generateTreeMapChart(chartOption, storeData);
                break;
            case ChartType.ProblemsDistribution:
                result[chartId] = generateHeatMapChart(chartOption, storeData);
                break;
            case ChartType.TestingPyramid:
                result[chartId] = generateTestingPyramidChart(chartOption, storeData);
                break;
            default:
                break;
        }
    }
    return result;
};
const hasOnlyDefaultEnvironment = (environments) => {
    return environments.length === 1 && environments[0] === DEFAULT_ENVIRONMENT;
};
export const generateCharts = async (chartsOptions, store, reportName, generateUuid, filter) => {
    const environments = await store.allEnvironments();
    const chartsData = {
        general: await generateChartData({ chartsOptions, store, reportName, generateUuid, filter }),
        byEnv: {},
    };
    if (hasOnlyDefaultEnvironment(environments)) {
        return chartsData;
    }
    for (const environment of environments) {
        chartsData.byEnv[environment] = await generateChartData({
            chartsOptions,
            store,
            reportName,
            env: environment,
            generateUuid,
            filter,
        });
    }
    return chartsData;
};
