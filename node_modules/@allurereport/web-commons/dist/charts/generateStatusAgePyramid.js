import { ChartType, DEFAULT_CHART_HISTORY_LIMIT } from "@allurereport/charts-api";
import { limitHistoryDataPoints } from "./chart-utils.js";
const createEmptyStats = () => {
    return STATUSES.reduce((acc, status) => {
        acc[status] = 0;
        return acc;
    }, {});
};
const STATUSES = ["failed", "broken", "skipped", "unknown"];
const isFBSUStatus = (status) => STATUSES.includes(status);
export const generateStatusAgePyramid = (props) => {
    const { options, storeData } = props;
    const { limit = DEFAULT_CHART_HISTORY_LIMIT } = options;
    const { historyDataPoints, testResults } = storeData;
    const currentReportTimestamp = testResults.reduce((acc, testResult) => Math.max(acc, testResult.stop ?? 0), 0);
    const limitedHistoryPoints = limitHistoryDataPoints(historyDataPoints, limit).sort((a, b) => a.timestamp - b.timestamp);
    if (limitedHistoryPoints.length === 0) {
        return {
            type: ChartType.StatusAgePyramid,
            title: options.title,
            data: [
                {
                    id: "current",
                    timestamp: currentReportTimestamp,
                    ...createEmptyStats(),
                },
            ],
            statuses: STATUSES,
        };
    }
    const hdps = limitedHistoryPoints.map((datapoint) => ({
        ...datapoint,
        testResults: Object.values(datapoint.testResults).reduce((acc, testResult) => {
            if (!testResult.historyId) {
                return acc;
            }
            const isInCurrentRun = testResults.findIndex((tr) => tr.historyId === testResult.historyId) !== -1;
            if (isInCurrentRun) {
                acc[testResult.historyId] = testResult;
            }
            return acc;
        }, {}),
    }));
    const dataPoints = [
        ...hdps.map((hdp) => ({
            ...hdp,
            ...createEmptyStats(),
        })),
        {
            testResults: testResults.reduce((acc, testResult) => {
                acc[testResult.historyId ?? testResult.id] = testResult;
                return acc;
            }, {}),
            uuid: "current",
            timestamp: currentReportTimestamp,
            ...createEmptyStats(),
        },
    ];
    dataPoints.forEach((dp, index, dps) => {
        const { testResults: trs } = dp;
        const historyAfter = dps.slice(index, dps.length - 1);
        const currentTrs = Object.values(trs);
        for (const cTr of currentTrs) {
            const currentTrStatus = cTr.status;
            if (!isFBSUStatus(currentTrStatus)) {
                continue;
            }
            const historyAfterTrsStatuses = historyAfter.map((hdp) => hdp.testResults[cTr.historyId]?.status ?? undefined);
            if (historyAfterTrsStatuses.some((status) => status !== currentTrStatus)) {
                continue;
            }
            dp[currentTrStatus]++;
        }
    });
    const data = dataPoints.map(({ uuid, timestamp, ...stats }) => ({
        id: uuid,
        timestamp,
        failed: stats.failed ?? 0,
        broken: stats.broken ?? 0,
        skipped: stats.skipped ?? 0,
        unknown: stats.unknown ?? 0,
    }));
    return {
        type: ChartType.StatusAgePyramid,
        title: options.title,
        data: data,
        statuses: STATUSES,
    };
};
