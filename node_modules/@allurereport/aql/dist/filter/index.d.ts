import type { AqlExpression, AqlParserConfig } from "../model.js";
type FilterContext = Map<string, any> | Record<string, any>;
/**
 * Filters an array of objects based on an AQL expression string.
 *
 * @param items - Array of objects to filter
 * @param aql - AQL string expression
 * @param context - Optional context map or object for function values
 * @param config - Optional parser configuration to restrict available features
 * @returns Filtered array of objects
 * @throws {AqlParserError} If the AQL string is invalid or uses forbidden features
 *
 * @example
 * ```typescript
 * const items = [{ status: "passed" }, { status: "failed" }];
 * const filtered = filterByAql(items, 'status = "passed"');
 * // Returns [{ status: "passed" }]
 * ```
 */
export declare function filterByAql<T extends Record<string, any>>(items: T[], aql: string, context?: FilterContext, config?: AqlParserConfig): T[];
/**
 * Filters an array of objects based on a parsed AQL expression.
 *
 * @param items - Array of objects to filter
 * @param expression - Pre-parsed AQL expression
 * @returns Filtered array of objects
 *
 * @example
 * ```typescript
 * const expr = parseAql('status = "passed"').expression;
 * const filtered = filterByAql(items, expr);
 * ```
 */
export declare function filterByAql<T extends Record<string, any>>(items: T[], expression: AqlExpression): T[];
/**
 * Creates a predicate function from an AQL expression.
 *
 * @param expression - The AQL expression to convert to a predicate
 * @returns A predicate function that takes an item and returns a boolean
 * @private
 */
export declare function createAqlPredicate(expression: AqlExpression): (item: any) => boolean;
export {};
